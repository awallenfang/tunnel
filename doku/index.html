<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tunnel Dokumentation</title>
</head>
<body>
    <main>
        <section>
            <h1>Tunnel Dokumentation</h1>
            <p>Das Prinzip dieses Projektes ist es zu experimentieren was alles mittels impliziter Grafik möglich ist und wo gegebenenfalls auch Schwierigkeiten im Vergleich zu expliziter Darstellung liegen.</p>
            <p>Dazu hat jeweils jede Person einen Tunnel in einem Shader implizit definiert und darauf verschiedene Effekte, wie Pathtracing und Ambient Occlusion implementiert, welche dann hintereinander gerendert werden.</p>
            <p>Die drei enstandenen Tunnel sind:
                <ul>
                    <li>
                        Ein Voxel basierter Tunnel, um mit Voxel Umformungen zu experimentieren
                    </li>
                    <li>
                        Ein Rohr um mit Echtzeiteffekten wie Ambient Occlusion und Shadow Mapping zu experimentieren
                    </li>
                    <li>
                        Eine Höhle um mit Lichtinteraktionen durch Pathtracing zu experimentieren
                    </li>
                </ul>
            </p>

            <p>
                Alle Tunnel wurden mittels Ray-Marching implementiert, wobei eine <abbr title="Signed Distance Function">SDF</abbr> definiert wird, welche zu eine Inputposition den Abstand zu der nächsten Position der Umgebung zurückgibt. <br> 
                Damit werden dann Strahlen in die Szene geschossen, bei denen jeweils die Entfernung der <abbr title="Signed Distance Function">SDF</abbr> nach vorne geschritten wird, bis ein Threshold erreicht wird. Zurückgegeben wird dann die insgesamt zurückgelegte Entfernung.
            </p>
        </section>
        <section>
            <h2>Voxel Tunnel</h2>
        </section>
        <section>
            <h2>Rohr</h2>
        </section>
        <section>
            <h2>Höhle</h2>
            <section>
                <h3>Vorab Bekannte Schwierigkeiten</h3>
                <p>
                    Ziel war es einen Pathtracer zu implementieren, durch den verschieden-farbige Lampen an den Wänden Licht an alle Stellen der Höhle strahlen können. <br>
                    Bevor überhaupt begonnen wurde war bereits klar, dass es unmöglich sein wird dies in Echtzeit umzusetzen, geschweige denn in kurzer Zeit zu rendern. 
                    Im Laufe der Arbeitszeit war die Überlegung das Pathtracing-System auch auf die anderen beiden Tunnel anzuwenden, was, aber den zeitlichen Rahmen für das Rendern sprengen würde. <br>
                    Dadurch ist das nun implementierte System aber sehr abgeschlossen und kann ohne viel Arbeit in ein weiteren Shader mit Ray-Marching übernommen werden.
                </p>

                <p>
                    Dabei war ebenfalls klar, dass man sich in einem Tunnel befindet und somit kein Sonnenlicht existiert. 
                    Dies hat zur Folge, dass ein Großteil der Strahlen bei simplem Pathtracing ins leere schießen und somit nicht zum Licht beitragen.
                </p>
            </section>
            <section>
                <h3>Umgebungsdefinition</h3>
                <p>
                    Begonnen wurde erstmal damit simple Formen und Operationen, wie Würfel und Rotationen zu definieren. <br>
                    Besonders bei der Rotation entstanden bereits einige komische Fehler, wie dass das rotierte Objekt abgeschnitten wird.
                </p>
                <img src="images/gem_1.png">
                <p>
                    Sobald alle Grundoperationen korrekt implementiert wurden war es relativ simpel den Rest der Grundszene zu bauen.
                </p>
                <p>
                    An dieser Stelle wird auf die <abbr title="Signed Distance Function">SDF</abbr> einfach eine Noise-Textur addiert, wodurch die rauhe Darstellung entsteht. Dies lädt aber auch diverses Experimentieren mit anderen Funktionen ein, wie modulierten sinus-Kurven.
                </p>
                <div>
                    <video width="40%" controls>
                        <source src="images/gem_2.mp4" type="video/mp4">
                    </video>
                    <video width="40%" controls>
                        <source src="images/gem_3.mp4" type="video/mp4">
                    </video>
                </div>
                
                <p>
                    Bei den stärkeren Noise-Operationen wird aber auch bereits eine schwäche von Ray-Marching offengelegt. Eine Addition auf Distantfunktionen resultiert nämlich nicht in einer weiteren korrekten Distanzfunktion, weswegen sich in diesem Fall die schwarzen Stellen entwickeln. <br>
                    An diesen Stellen springt der Strahl wegen den falschen Distanzfunktionen zu weit und trifft das korrekte Ziel somit nicht. 
                </p>

                <p>
                    Es existiert aber auch eine Lösung zu diesem Problem, welche aber um einiges mehr Rechenzeit benötigt. 
                    Dabei werden iterativ immer kleiner werdende Objekte an der Wand platziert und mit dieser verbunden. 
                    Dadurch entsteht eine rauhe Darstellung, ohne, dass die <abbr title="Signed Distance Function">SDF</abbr> falsch wird.
                </p>

                <img src="images/gem_4.png">

                <p>
                    Der nächste Schritt ist es eine Möglichkeit zu haben um aus der Distanzfunktion auch Materialinformationen zu erhalten. Um dies zu erreichen wird aus jeder <abbr title="Signed Distance Function">SDF</abbr> nun anstelle einer Distanz, ein "Object" zurückgegeben, welches die Distanzinformationen, sowie Materialinfos beinhält. <br>
                    Diese können dann bei dem Rendering genutzt werden.
                </p>

                <p>
                    Der letzte Schritt ist es nun die Lampenpositionen zu definieren. Anfänglich waren diese statisch auch in dem Shader definiert, aber dies ist sehr unhandlich, da wegen dem Fehlen eines Sonnenlichtes sehr viele Lampen nötig sind. <br>
                    Deswegen wurden diese außerhalb in c++ generiert und dann mit Uniforms in den Shader eingebunden. Die <abbr title="Signed Distance Function">SDF</abbr> für die Lampen iteriert über alle Lampen und gibt die mit der kleinsten Entfernung am Ende aus.
                </p>
            </section>

            <section>
                <h3>Rendering</h3>
                <p>
                    Anfänglich wurden zum Testen von der Umgebung die Schatten direkt basierend auf Punktlichtquellen implementiert, was aber schnell auch mit dem neuen Pathtracer ersetzt wurde. <br>
                    Dabei entstanden aber auch bereits Probleme mit falschen <abbr title="Signed Distance Function">SDF</abbr>-Werten, wodurch Schatten falsche berechnet wurden. <br> 
                </p>

                <img src="images/gem_5.png">

                <p>
                    Der Pathtracer ist ein simpler cosine-weighted Pathtracer, da es zeitlich leider nicht möglich war, weitere schnellere Gewichtungen erfolgreich zu implementieren. <br>
                    Die größte Schwierigkeit dabei war es den Code korrekt zu implementieren, sodass der PC bei dem Ausführen nicht wegen der großen Last im Shader abstürzt und den folgenden Output generiert.
                </p>

                <img src="images/gem_6.png">

                <p>
                    Dies wurde gelöst, indem pro Shader-Durchlauf nur ein einziger Sample berechnet wird und diese Outputs dann mithilfe des Alpha-Kanals in OpenGL addiert werden, bis das vollständige Bild gerendert wurde. <br>
                    Bei dem setzen des Alpha-Wertes wird noch die Stärke der Farben insgesamt erhöht, indem Alpha nicht auf 1/samples gesetzt wird, sondern nur auf 1/5, da ein großteil der Samples schwarz sind. Dadurch wird zwar teilweise Realismus verloren, aber die Konvergenz wird erhöht.
                </p>
            </section>
        </section>
    </main>
</body>
</html>